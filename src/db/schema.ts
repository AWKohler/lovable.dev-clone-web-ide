import { pgTable, uuid, timestamp, text, jsonb, integer, bigint, uniqueIndex, index } from 'drizzle-orm/pg-core';

export const projects = pgTable('projects', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: text('name').notNull(),
  userId: text('user_id').notNull(), // Clerk user id
  platform: text('platform').notNull().default('web'), // 'web' | 'mobile'
  // Preferred model for this project: 'gpt-4.1' | 'claude-sonnet-4.5'
  model: text('model').notNull().default('gpt-4.1'),
  // Snapshot URLs for project thumbnails and HTML captures
  thumbnailUrl: text('thumbnail_url'),
  htmlSnapshotUrl: text('html_snapshot_url'),
  // UploadThing file keys for deletion (format: "fileKey" from uploadthing)
  thumbnailKey: text('thumbnail_key'),
  htmlSnapshotKey: text('html_snapshot_key'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export type Project = typeof projects.$inferSelect;
export type NewProject = typeof projects.$inferInsert;

// Chat session per project (one active session per project)
export const chatSessions = pgTable('chat_sessions', {
  id: uuid('id').primaryKey().defaultRandom(),
  projectId: uuid('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// Store all messages as JSON to preserve all parts (tool-calls, data, etc.)
export const chatMessages = pgTable(
  'chat_messages',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    sessionId: uuid('session_id').notNull().references(() => chatSessions.id, { onDelete: 'cascade' }),
    // Original message id from the client/useChat to dedupe
    messageId: text('message_id').notNull(),
    role: text('role').notNull(),
    content: jsonb('content').notNull(),
    createdAt: timestamp('created_at').defaultNow().notNull(),
  },
  (t) => ({
    sessionMessageUnique: uniqueIndex('chat_messages_session_message_unique').on(t.sessionId, t.messageId),
  })
);

export type ChatSession = typeof chatSessions.$inferSelect;
export type NewChatSession = typeof chatSessions.$inferInsert;
export type ChatMessage = typeof chatMessages.$inferSelect;
export type NewChatMessage = typeof chatMessages.$inferInsert;

// Supabase linkage between a platform project and a Supabase project
export const supabaseLinks = pgTable('supabase_links', {
  id: uuid('id').primaryKey().defaultRandom(),
  projectId: uuid('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  userId: text('user_id').notNull(),
  organizationId: text('organization_id'),
  organizationName: text('organization_name'),
  supabaseProjectRef: text('supabase_project_ref').notNull(),
  supabaseProjectUrl: text('supabase_project_url').notNull(),
  // Note: store anon key server-side only. In production, encrypt-at-rest.
  supabaseAnonKey: text('supabase_anon_key'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (t) => ({
  linkPerProjectUnique: uniqueIndex('supabase_links_project_unique').on(t.projectId),
}));

export type SupabaseLink = typeof supabaseLinks.$inferSelect;
export type NewSupabaseLink = typeof supabaseLinks.$inferInsert;

// Per-user API key storage (BYOK)
export const userSettings = pgTable('user_settings', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: text('user_id').notNull(), // Clerk user id
  openaiApiKey: text('openai_api_key'),
  anthropicApiKey: text('anthropic_api_key'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (t) => ({
  userUnique: uniqueIndex('user_settings_user_unique').on(t.userId),
}));

export type UserSettings = typeof userSettings.$inferSelect;
export type NewUserSettings = typeof userSettings.$inferInsert;

// Cloud backup tables for project files
export const projectFiles = pgTable('project_files', {
  id: uuid('id').primaryKey().defaultRandom(),
  projectId: uuid('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  path: text('path').notNull(),
  content: text('content').notNull(),
  hash: text('hash').notNull(),
  size: integer('size').notNull(),
  mimeType: text('mime_type'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (t) => ({
  projectPathUnique: uniqueIndex('project_files_project_path_unique').on(t.projectId, t.path),
  projectIdIdx: index('project_files_project_id_idx').on(t.projectId),
  hashIdx: index('project_files_hash_idx').on(t.hash),
}));

export type ProjectFile = typeof projectFiles.$inferSelect;
export type NewProjectFile = typeof projectFiles.$inferInsert;

export const projectAssets = pgTable('project_assets', {
  id: uuid('id').primaryKey().defaultRandom(),
  projectId: uuid('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  path: text('path').notNull(),
  uploadThingUrl: text('upload_thing_url').notNull(),
  uploadThingKey: text('upload_thing_key').notNull(),
  hash: text('hash').notNull(),
  size: integer('size').notNull(),
  mimeType: text('mime_type'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (t) => ({
  projectPathUnique: uniqueIndex('project_assets_project_path_unique').on(t.projectId, t.path),
  projectIdIdx: index('project_assets_project_id_idx').on(t.projectId),
}));

export type ProjectAsset = typeof projectAssets.$inferSelect;
export type NewProjectAsset = typeof projectAssets.$inferInsert;

export const projectSyncManifests = pgTable('project_sync_manifests', {
  id: uuid('id').primaryKey().defaultRandom(),
  projectId: uuid('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  fileManifest: jsonb('file_manifest').notNull(),
  totalFiles: integer('total_files').notNull().default(0),
  totalSize: bigint('total_size', { mode: 'number' }).notNull().default(0),
  lastSyncAt: timestamp('last_sync_at').defaultNow().notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (t) => ({
  projectUnique: uniqueIndex('project_sync_manifests_project_unique').on(t.projectId),
  projectIdIdx: index('project_sync_manifests_project_id_idx').on(t.projectId),
}));

export type ProjectSyncManifest = typeof projectSyncManifests.$inferSelect;
export type NewProjectSyncManifest = typeof projectSyncManifests.$inferInsert;
